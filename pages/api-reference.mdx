---
metaDescription: Rulebricks API documentation, including SDKs for Python, Node.js, Java, and Go.
---

import ApiReference from '../components/ApiReference'

### Rulebricks API

<ApiReference />

import { Callout } from 'nextra/components'

<Callout type="info" emoji="ðŸ”Ž">
  Looking for API documentation based on **specific rules** you've published?
  Find our [Automated
  Documentation](https://www.rulebricks.com/blog/introducing-automated-documentation)
  feature in the API section of your Rulebricks Dashboard.
</Callout>

---

### Rulebricks SDK

Rulebricks SDK's make it possible to use rules in your applications in as few as 3 lines of code. We currently provide SDKs for [Python](#python), [Node.js/Typescript](#nodejstypescript), [Java](#java), and [Go](#go), with more coming soon.

#### <ins>Python</ins>

[![pypi](https://img.shields.io/pypi/v/rulebricks.svg)](https://pypi.python.org/pypi/rulebricks)

The [Rulebricks Python SDK](https://github.com/rulebricks/python-sdk) provides convenient access to the Rulebricks API from Python. SDK usage largely mirrors the API itself, with methods for solving rules, bulk solving rules, and more.

##### Installation

Add this dependency to your project's build file:

```bash
pip install rulebricks
# or
poetry add rulebricks
```

##### Configuration

Before using the SDK, configure your API key. You can find your API key in your Rulebricks Dashboard.

```python
import rulebricks as rb

# Replace 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX' with your actual API key
rb.configure(
    api_key="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
    # base_url="https://rulebricks.com" # Optional: Use this to override the default base URL for private cloud deployments
    # timeout=10 # Optional: Use this to override the default timeout in seconds
)
```

##### Basic Usage

Using the SDK to interact with the Rulebricks API in a synchronous manner is simple.

Here's an example of how to use our Python SDK to solve a rule:

```python
import rulebricks as rb

# Set the API key
rb.configure(
    api_key="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
)

result = rb.rules.solve(
    slug="tJOCd8XXXX",
    request={
        "customer_id": "anc39as3",
        "purchase_history": ["t-shirt", "mug"],
        "account_age_days": 4,
        "last_purchase_days_ago": 3,
        "email_subscription": False
    }
)

print(result)
```

##### Asynchronous Usage

For asynchronous API calls, access methods via the async_api attribute.

This allows you to leverage Python's asyncio library for non-blocking operations:

```python
import rulebricks as rb
import asyncio

# Set the API key
rb.configure(
    api_key="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
)

async def main():
    async_result = await rb.async_api.rules.solve(
        slug="tJOCd8XXXX",
        request={
            "customer_id": "anc39as3",
            "purchase_history": ["t-shirt", "mug"],
            "account_age_days": 4,
            "last_purchase_days_ago": 3,
            "email_subscription": False
        }
    )
    print(async_result)

if __name__ == "__main__":
    asyncio.run(main())
```

Using a combination of `solve`, `bulk_solve`, `parallel_solve` and `flows` in synchronous or asynchronous modes gives you high flexibility to interact with the Rulebricks API in a way that best suits your application's needs.

##### Forge SDK

The Forge SDK is a powerful tool within the Rulebricks package that allows you to programmatically create and manage rules. It provides a flexible and intuitive way to define rule sets, conditions, and responses.

Looking for more comprehensive documentation? Read through our [Forge SDK implementation examples](https://github.com/rulebricks/examples).

###### Purpose

The Forge SDK enables you to:
- Define complex and large rule structures
- Create and manage conditions within rules
- Specify request and response schemas
- Generate rule representations in various formats (JSON, tabular, file)

###### Field Types

These operators match the ones available to you when defining conditions in the Rulebricks decision table editor.
We are always adding more operators, so the lists below likely will not be exhaustive.

####### Boolean Fields

Boolean fields support these operations:

```python
boolean_field = rule.add_boolean_field("field_name")
boolean_field.equals(True)    # Check if true
boolean_field.equals(False)   # Check if false
boolean_field.any()           # Match any value
```

####### Number Fields

Number fields support these operations:

```python
number_field = rule.add_number_field("field_name")
number_field.equals(value)                    # Exact match
number_field.not_equals(value)                # Not equal to
number_field.greater_than(value)              # Greater than
number_field.less_than(value)                 # Less than
number_field.greater_than_or_equal(value)     # Greater than or equal to
number_field.less_than_or_equal(value)        # Less than or equal to
number_field.between(start, end)              # Between two values (inclusive)
number_field.not_between(start, end)          # Not between two values
number_field.is_even()                        # Check if even
number_field.is_odd()                         # Check if odd
number_field.is_positive()                    # Check if positive
number_field.is_negative()                    # Check if negative
number_field.is_zero()                        # Check if zero
number_field.is_not_zero()                    # Check if not zero
number_field.is_multiple_of(value)            # Check if multiple of value
number_field.is_not_multiple_of(value)        # Check if not multiple of value
number_field.is_power_of(base)                # Check if power of base
```

####### String Fields

String fields support these operations:

```python
string_field = rule.add_string_field("field_name")
string_field.contains(value)                # Contains substring
string_field.not_contains(value)            # Does not contain substring
string_field.equals(value)                  # Exact match
string_field.not_equals(value)              # Not equal to
string_field.is_empty()                     # Check if empty
string_field.is_not_empty()                 # Check if not empty
string_field.starts_with(value)             # Starts with prefix
string_field.ends_with(value)               # Ends with suffix
string_field.is_included_in(list)           # Value is in list
string_field.is_not_included_in(list)       # Value is not in list
string_field.contains_any_of(list)          # Contains any value from list
string_field.not_contains_any_of(list)      # Contains none from list
string_field.matches_regex(pattern)         # Matches regex pattern
string_field.not_matches_regex(pattern)     # Does not match regex
string_field.is_email()                     # Is valid email
string_field.is_not_email()                 # Is not valid email
string_field.is_url()                       # Is valid URL
string_field.is_not_url()                   # Is not valid URL
string_field.is_ip()                        # Is valid IP address
string_field.is_not_ip()                    # Is not valid IP address
```

####### Date Fields

Date fields support these operations:

```python
date_field = rule.add_date_field("field_name")
date_field.is_past()                        # Date is in the past
date_field.is_future()                      # Date is in the future
date_field.days_ago(days)                   # Exact number of days ago
date_field.less_than_days_ago(days)         # Less than N days ago
date_field.more_than_days_ago(days)         # More than N days ago
date_field.days_from_now(days)              # Exact number of days from now
date_field.less_than_days_from_now(days)    # Less than N days from now
date_field.more_than_days_from_now(days)    # More than N days from now
date_field.is_today()                       # Is today
date_field.is_this_week()                   # Is this week
date_field.is_this_month()                  # Is this month
date_field.is_this_year()                   # Is this year
date_field.after(date)                      # After date
date_field.on_or_after(date)                # On or after date
date_field.before(date)                     # Before date
date_field.on_or_before(date)               # On or before date
date_field.between(start, end)              # Between two dates
date_field.not_between(start, end)          # Not between two dates
```

####### List Fields

List fields support these operations:

```python
list_field = rule.add_list_field("field_name")
list_field.contains(value)                  # Contains value
list_field.is_empty()                       # Is empty list
list_field.is_not_empty()                   # Is not empty
list_field.length_equals(length)            # Has exact length
list_field.length_not_equals(length)        # Does not have length
list_field.longer_than(length)              # Longer than length
list_field.shorter_than(length)             # Shorter than length
list_field.contains_all(values)             # Contains all values
list_field.contains_any(values)             # Contains any value
list_field.contains_none(values)            # Contains none of values
list_field.equals(other)                    # Equals another list
list_field.not_equals(other)                # Not equal to list
list_field.has_duplicates()                 # Has duplicate values
list_field.no_duplicates()                  # Has no duplicates
```

###### Creating a Rule

Here's an example of how to create a simple rule using the Forge SDK:

```python
from rulebricks import RuleBuilder, RuleType
from rulebricks.forge import BooleanOperator, NumberOperator, StringOperator, boolean_op, number_op, string_op

# Initialize a new RuleBuilder
builder = RuleBuilder()

# Set name and description
builder.set_name("Customer Discount Eligibility")
builder.set_description("Determines if a customer is eligible for a discount based on their purchase history and account status.")

# Define schema
builder.add_request_field("purchase_count", "Purchase Count", RuleType.NUMBER, "Number of purchases made", 0)
builder.add_request_field("is_subscribed", "Is Subscribed", RuleType.BOOLEAN, "Whether the customer is subscribed to the newsletter", False)
builder.add_request_field("customer_type", "Customer Type", RuleType.STRING, "Type of customer (regular, premium, vip)", "regular")

builder.add_response_field("discount_eligible", "Discount Eligible", RuleType.BOOLEAN, "Whether the customer is eligible for a discount", False)
builder.add_response_field("discount_percentage", "Discount Percentage", RuleType.NUMBER, "Percentage of discount to apply", 0)

# Create conditions
condition1 = builder.add_condition()
builder.update_condition(condition1, "purchase_count", *number_op(NumberOperator.GREATER_THAN_OR_EQUAL_TO)(10))
builder.update_condition(condition1, "is_subscribed", *boolean_op(BooleanOperator.IS_TRUE)())
builder.update_condition(condition1, "customer_type", *string_op(StringOperator.EQUALS)("regular"))
builder.set_condition_response(condition1, "discount_eligible", True)
builder.set_condition_response(condition1, "discount_percentage", 5)

condition2 = builder.add_condition()
builder.update_condition(condition2, "customer_type", *string_op(StringOperator.EQUALS)("premium"))
builder.set_condition_response(condition2, "discount_eligible", True)
builder.set_condition_response(condition2, "discount_percentage", 10)
```

###### Available Operators

The Forge SDK provides a range of operators for different data types. You can find the full list of available operators in the following files:

- `src/rulebricks/forge/operators.py`

This file contains the definitions for `BooleanOperator`, `NumberOperator`, `StringOperator`, `DateOperator`, and `ListOperator`.

###### Outputting Rules

The Forge SDK offers several ways to output your rules:

1. **JSON Output**

   To get a JSON representation of your rule:

   ```python
   json_output = builder.to_json()
   print(json_output)
   ```

2. **Pretty Print (Tabular Format)**

   To get a human-readable tabular representation of your rule:

   ```python
   table_output = builder.to_table()
   print(table_output)
   ```

   This might produce output similar to:

   ```
   +---------------+---------------+-----------------+-------------------+----------------------+
   | purchase_count | is_subscribed |  customer_type  | discount_eligible | discount_percentage  |
   +===============+===============+=================+===================+======================+
   | greater than   | is true       | equals          | True              | 5                    |
   | or equal to    | ()            | (regular)       |                   |                      |
   | (10)           |               |                 |                   |                      |
   +---------------+---------------+-----------------+-------------------+----------------------+
   | -              | -             | equals          | True              | 10                   |
   |                |               | (premium)       |                   |                      |
   +---------------+---------------+-----------------+-------------------+----------------------+
   ```

3. **Export to File**

   To export your rule to a file for import through the Rulebricks UI:

   ```python
   filename = builder.export()
   print(f"Rule exported to: {filename}")
   ```

   This will create a file with the `.rbx` extension in your current directory. The filename will be based on the rule name you set, with "-Generated.rbx" appended.

###### Complete Example

Here's a complete example that demonstrates creating a rule and using all output methods:

```python
from rulebricks import RuleBuilder, RuleType
from rulebricks.forge import BooleanOperator, NumberOperator, StringOperator, boolean_op, number_op, string_op

def create_customer_discount_rule():
    builder = RuleBuilder()

    builder.set_name("Customer Discount Eligibility")
    builder.set_description("Determines if a customer is eligible for a discount based on their purchase history and account status.")

    builder.add_request_field("purchase_count", "Purchase Count", RuleType.NUMBER, "Number of purchases made", 0)
    builder.add_request_field("is_subscribed", "Is Subscribed", RuleType.BOOLEAN, "Whether the customer is subscribed to the newsletter", False)
    builder.add_request_field("customer_type", "Customer Type", RuleType.STRING, "Type of customer (regular, premium, vip)", "regular")

    builder.add_response_field("discount_eligible", "Discount Eligible", RuleType.BOOLEAN, "Whether the customer is eligible for a discount", False)
    builder.add_response_field("discount_percentage", "Discount Percentage", RuleType.NUMBER, "Percentage of discount to apply", 0)

    condition1 = builder.add_condition()
    builder.update_condition(condition1, "purchase_count", *number_op(NumberOperator.GREATER_THAN_OR_EQUAL_TO)(10))
    builder.update_condition(condition1, "is_subscribed", *boolean_op(BooleanOperator.IS_TRUE)())
    builder.update_condition(condition1, "customer_type", *string_op(StringOperator.EQUALS)("regular"))
    builder.set_condition_response(condition1, "discount_eligible", True)
    builder.set_condition_response(condition1, "discount_percentage", 5)

    condition2 = builder.add_condition()
    builder.update_condition(condition2, "customer_type", *string_op(StringOperator.EQUALS)("premium"))
    builder.set_condition_response(condition2, "discount_eligible", True)
    builder.set_condition_response(condition2, "discount_percentage", 10)

    return builder

if __name__ == "__main__":
    rule = create_customer_discount_rule()

    # JSON output
    print("JSON Output:")
    print(rule.to_json())
    print("\n")

    # Table output
    print("Table Output:")
    print(rule.to_table())
    print("\n")

    # Export to file
    filename = rule.export()
    print(f"Rule exported to: {filename}")
```

---

#### <ins>Node.js/Typescript</ins>

[![npm shield](https://img.shields.io/npm/v/@rulebricks/api)](https://www.npmjs.com/package/@rulebricks/api)

The [Rulebricks Node.js library](https://github.com/rulebricks/node-sdk) provides convenient access to the Rulebricks API from JavaScript/TypeScript. SDK usage largely mirrors the API itself, with methods for solving rules, bulk solving rules, and more.

##### Installation

```
npm install --save @rulebricks/api
# or
yarn add @rulebricks/api
```

##### Usage

```typescript
import { RulebricksClient } from '@rulebricks/api';

const rulebricks = new RulebricksClient({
  apiKey: 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX',
  environment: 'https://rulebricks.com',
});

rulebricks.rules.solve('tJOCd8XXXX', {
  customer_id: 'anc39as3',
  purchase_history: ['t-shirt', 'mug'],,
  account_age_days: 4,
  last_purchase_days_ago: 3,
  email_subscription: false,
}, {
  // Request options (Optional, leave empty for default values)
  // timeoutInSeconds: 10, (Optional: Use this to override the default timeout in seconds)
  // maxRetries: 3, (Optional: Use this to override the default number of retries)
}).then((result) => {
  console.log(result);
}).catch((err) => {
  console.error(err);
});
```

##### Handling errors

When the API returns a non-success status code (4xx or 5xx response), a subclass of `RulebricksApiError` will be thrown:

```ts
try {
  // ...
} catch (err) {
  if (err instanceof RulebricksApiError) {
    console.log(err.statusCode) // 400
    console.log(err.message) // "BadRequestError"
    console.log(err.body) // list of errors
  }
}
```

Error codes are as followed:

| Status Code | Error Type            |
| ----------- | --------------------- |
| 400         | `BadRequestError`     |
| 429         | `RateLimitError`      |
| 500         | `InternalServerError` |

##### Contributing

This library is generated programmatically. We suggest [opening an issue](https://github.com/rulebricks/node-sdk/issues) to discuss any issues or feature requests with us.

##### License

This project is licensed under the MIT License - see the [LICENSE](LICENSE.txt) file for details.

---

#### <ins>Java</ins>

The [Rulebricks Java SDK](https://github.com/rulebricks/java-sdk) provides convenient access to the Rulebricks API from Java applications. SDK usage allows for solving rules, bulk solving rules, and more.

##### Installation

For Maven, add this dependency to your project's `pom.xml` file:

```xml
<dependency>
  <groupId>com.rulebricks</groupId>
  <artifactId>rulebricks-sdk-java</artifactId>
  <version>1.0.0</version>
</dependency>
```

For Gradle, add this to your `build.gradle` file:

```groovy
implementation 'com.rulebricks:rulebricks-sdk-java:1.0.0'
```

##### Configuration

Instantiate a `RulebricksApiClient` with your API key:

```java
RulebricksApiClient client = RulebricksApiClient.builder()
    .apiKey("YOUR_API_KEY")
    .build();
```

##### Basic Usage

Solve a rule:

```java
Map<String, Object> requestData = new HashMap<>();
requestData.put("dataKey", "dataValue");

Map<String, Object> result = client.rules().solve("<rule-slug>", requestData);
```

Bulk solve rules:

```java
List<Map<String, Object>> requestDataList = new ArrayList<>();
requestDataList.add(requestData);

List<Map<String, Object>> results = client.rules().bulkSolve("<rule-slug>", requestDataList);
```

Parallel solving rules requires a particular format using `$rule` alongside respective data payloads:

```java
Map<String, Map<String, Object>> requestDataMap = new HashMap<>();
requestDataMap.put("eligibility", {
    "$rule": "1ef03ms",
    "customer_id": "anc39as3",
    "purchase_history": ["t-shirt", "mug"],
    "account_age_days": 4,
    "last_purchase_days_ago": 3,
    "email_subscription": false
});
requestDataMap.put("offers", {
    "$rule": "OvmsYwn",
    "customer_id": "anc39as3",
    "last_purchase_days_ago": 3,
    "selected_plan": "premium"
});

Map<String, Object> results = client.rules().parallelSolve(requestDataMap);
```

##### Error Handling

The SDK throws exceptions to indicate API errors:

```java
try {
    Map<String, Object> result = client.rules().solve("<rule-slug>", requestData);
} catch (Exception e) {
    // Handle the error
}
```

##### Feedback and Contributions

Feedback and contributions are welcome. Please report any issues or suggestions through the [GitHub issue tracker](https://github.com/rulebricks/java-sdk/issues).

##### License

The Rulebricks Java SDK is released under the MIT License. See the LICENSE file for more details.

---

#### <ins>Go</ins>

The [Rulebricks Go SDK](https://github.com/rulebricks/go-sdk) provides convenient access to the Rulebricks API from Go applications. SDK usage largely mirrors the API itself, with methods for solving rules, bulk solving rules, and more.

##### Installation

To use the Rulebricks Go SDK in your project, you can install it using `go get`:

```sh
go get github.com/rulebricks/go-sdk
```

##### Configuration

Before you can start using the SDK, you need to configure it with your Rulebricks API key. You can do this by creating a client with the `NewClient` function and passing in your API key as a request option:

```go
import (
    "github.com/rulebricks/go-sdk/client"
    "github.com/rulebricks/go-sdk/option"
    "net/http"
)

opts := option.WithAPIKey("YOUR_API_KEY")
client := client.NewClient(opts)
```

##### Basic Usage

To solve a rule with the SDK, you can use the `Solve` function of the client. Here's an example of how to solve a rule identified by its unique slug:

```go
response, err := client.Rules.Solve(context.Background(), "<rule-slug>", map[string]interface{}{
    "data": "your-data-here",
})
if err != nil {
    // Handle error
}
// Use the response
```

For bulk operations, you can use the `BulkSolve` function to execute a rule against multiple data payloads:

```go
responses, err := client.Rules.BulkSolve(context.Background(), "<rule-slug>", []map[string]interface{}{
    {"data": "first-payload"},
    {"data": "second-payload"},
    // Add more payloads as needed
})
if err != nil {
    // Handle error
}
// Use the responses
```

To execute multiple rules in parallel, use the `ParallelSolve` function, along with the special parallel solve format:

```go
responses, err := client.Rules.ParallelSolve(context.Background(), map[string]interface{}{
    "eligibility":  {"$rule": "tJOCd8XX", "customer_id": "anc39as3", "purchase_history": []string{"t-shirt", "mug"}, "account_age_days": 4, "last_purchase_days_ago": 3, "email_subscription": false},
    "offers": {"$rule": "Ovms3XX", "customer_id": "anc39as3", "last_purchase_days_ago": 3, "selected_plan": "premium"},
    // Note the non top-level keyword $rule is used to identify the rule to be executed
    // alongside the data payload that should be passed to that particular rule
})
if err != nil {
    // Handle error
}
// Use the responses
```

##### Asynchronous Usage

The SDK supports asynchronous operations using Go routines. You can use the `Solve`, `BulkSolve`, and `ParallelSolve` functions within a goroutine for concurrent rule solving:

```go
go func() {
    response, err := client.Rules.Solve(context.Background(), "<rule-slug>", map[string]interface{}{
        "data": "your-data-here",
    })
    if err != nil {
        // Handle error
    }
    // Use the response
}()
```

##### Error Handling

The SDK returns errors that can be handled in a typical Go error handling pattern:

```go
response, err := client.Rules.Solve(...)
if err != nil {
    // Handle the error
}
```

##### Feedback and Contributions

We welcome feedback and contributions to the SDK. Please report any issues or suggestions through the [GitHub issue tracker](https://github.com/rulebricks/go-sdk/issues).

For contributions, please submit a pull request with a clear description of the changes and any relevant tests.

##### License

The Rulebricks Go SDK is released under the MIT License. See the LICENSE file for more details.

---

#### <ins>C#</ins>

The [Rulebricks C# SDK](https://github.com/rulebricks/csharp-sdk) provides convenient access to the Rulebricks API from C# applications. SDK usage allows for solving rules, bulk solving rules, and more.

##### Installation

To install the Rulebricks C# SDK, add the following package to your project:

```sh
dotnet add package RulebricksApi
```

##### Configuration

Instantiate a `RulebricksApiClient` with your API key:

```csharp
var client = new RulebricksApiClient("YOUR_API_KEY");
```

##### Basic Usage

Solve a rule:

```csharp
var requestData = new Dictionary<string, object>
{
    { "dataKey", "dataValue" }
};

var result = client.Rules.Solve("<rule-slug>", requestData);
```

Bulk solve rules:

```csharp
var requestDataList = new List<Dictionary<string, object>>
{
    new Dictionary<string, object> { { "dataKey", "dataValue" } }
};

var results = client.Rules.BulkSolve("<rule-slug>", requestDataList);
```

Parallel solving rules requires a particular format using `$rule` alongside respective data payloads:

```csharp
var requestDataMap = new Dictionary<string, Dictionary<string, object>>
{
    { "eligibility", new Dictionary<string, object>
        {
            { "$rule", "1ef03ms" },
            { "customer_id", "anc39as3" },
            { "purchase_history", new List<string> { "t-shirt", "mug" } },
            { "account_age_days", 4 },
            { "last_purchase_days_ago", 3 },
            { "email_subscription", false }
        }
    },
    { "offers", new Dictionary<string, object>
        {
            { "$rule", "OvmsYwn" },
            { "customer_id", "anc39as3" },
            { "last_purchase_days_ago", 3 },
            { "selected_plan", "premium" }
        }
    }
};

var results = client.Rules.ParallelSolve(requestDataMap);
```

##### Error Handling

The SDK throws exceptions to indicate API errors:

```csharp
try
{
    var result = client.Rules.Solve("<rule-slug>", requestData);
}
catch (Exception e)
{
    // Handle the error
}
```

##### Forge Module

The Forge module provides a fluent interface for creating and managing rules in your Rulebricks workspace. It offers a type-safe way to define rules, fields, conditions, and dynamic values.

###### Rule Creation

```csharp
using RulebricksApi.Forge;

// Create a new rule
var rule = new Rule()
    .SetName("Health Insurance Account Selector")
    .SetDescription("Assists individuals in selecting the most suitable health insurance account option.")
    .SetWorkspace(client);

// Add fields to capture request data
rule
    .AddNumberField("age", "Age of individual", 0)
    .AddBooleanField("hasChronicCondition", "Has any chronic conditions", false)
    .AddNumberField("annualIncome", "Annual income in USD", 0)
    .AddStringField("preferredHospital", "Preferred hospital name")
    .AddListField("currentMedications", "List of current medications");

// Add response fields
rule
    .AddStringResponse("recommendedPlan", "Recommended insurance plan")
    .AddNumberResponse("monthlyPremium", "Monthly premium amount")
    .AddBooleanResponse("hsaEligible", "Eligible for Health Savings Account");

// Create conditions using When() and Any()
rule
    .When(new Dictionary<string, object[]>
    {
        { "age", new object[] { "greater_than", 65 } },
        { "hasChronicCondition", new object[] { "equals", true } }
    })
    .Then(new Dictionary<string, object>
    {
        { "recommendedPlan", "Medicare Advantage Plus" },
        { "monthlyPremium", 175.50 },
        { "hsaEligible", false }
    });

rule
    .Any(new Dictionary<string, object[]>
    {
        { "annualIncome", new object[] { "less_than", 30000 } },
        { "hasChronicCondition", new object[] { "equals", true } }
    })
    .Then(new Dictionary<string, object>
    {
        { "recommendedPlan", "Essential Care Plus" },
        { "monthlyPremium", 125.00 },
        { "hsaEligible", true }
    });

// Save the rule to your workspace
await rule.Update();
```

###### Dynamic Values

The Forge module also supports dynamic values that can be managed across your workspace:

```csharp
using RulebricksApi.Forge;

// Configure dynamic values with your workspace
DynamicValues.Configure(client);

// Set dynamic values
await DynamicValues.Set(new Dictionary<string, object>
{
    { "maxDeductible", 5000 },
    { "minPremium", 50 },
    { "availablePlans", new[] { "Basic", "Standard", "Premium" } }
});

// Get a dynamic value reference
var maxDeductible = await DynamicValues.Get("maxDeductible");

// Use dynamic values in rules
rule
    .When(new Dictionary<string, object[]>
    {
        { "annualIncome", new object[] { "greater_than", 50000 } }
    })
    .Then(new Dictionary<string, object>
    {
        { "monthlyPremium", maxDeductible }
    });
```

###### Type Safety

The Forge module is built with strong typing and provides compile-time type checking:

```csharp
// Field types are enforced at compile time
rule.AddNumberField("age", "Age of individual", "invalid"); // Compiler error
rule.AddBooleanField("isActive", "Is account active", 0); // Compiler error

// Operator types are validated
rule.When(new Dictionary<string, object[]>
{
    { "age", new object[] { "contains", "value" } }, // Runtime error: 'contains' not valid for number fields
    { "isActive", new object[] { "greater_than", true } } // Runtime error: 'greater_than' not valid for boolean fields
});
```

##### Feedback and Contributions

Feedback and contributions are welcome. Please report any issues or suggestions through the [GitHub issue tracker](https://github.com/rulebricks/csharp-sdk/issues).

##### License

The Rulebricks C# SDK is released under the MIT License. See the LICENSE file for more details.

---

#### <ins>Ruby</ins>

The [Rulebricks Ruby SDK](https://github.com/rulebricks/ruby-sdk) provides convenient access to the Rulebricks API from Ruby applications. SDK usage allows for solving rules, bulk solving rules, and more.

##### Installation

To install the Rulebricks Ruby SDK, add the following line to your Gemfile:

```ruby
gem 'rulebricks_api_client'
```

Then run:

```sh
bundle install
```

##### Configuration

Configure the SDK with your API key:

```ruby
require 'rulebricks_api_client'

RulebricksApiClient.configure do |config|
  config.api_key = 'YOUR_API_KEY'
end
```

##### Basic Usage

Solve a rule:

```ruby
request_data = {
  dataKey: 'dataValue'
}

result = RulebricksApiClient::Rules.solve('<rule-slug>', request_data)
```

Bulk solve rules:

```ruby
request_data_list = [
  { dataKey: 'dataValue' }
]

results = RulebricksApiClient::Rules.bulk_solve('<rule-slug>', request_data_list)
```

Parallel solving rules requires a particular format using `$rule` alongside respective data payloads:

```ruby
request_data_map = {
  eligibility: {
    '$rule' => '1ef03ms',
    customer_id: 'anc39as3',
    purchase_history: ['t-shirt', 'mug'],
    account_age_days: 4,
    last_purchase_days_ago: 3,
    email_subscription: false
  },
  offers: {
    '$rule' => 'OvmsYwn',
    customer_id: 'anc39as3',
    last_purchase_days_ago: 3,
    selected_plan: 'premium'
  }
}

results = RulebricksApiClient::Rules.parallel_solve(request_data_map)
```

##### Error Handling

The SDK raises exceptions to indicate API errors:

```ruby
begin
  result = RulebricksApiClient::Rules.solve('<rule-slug>', request_data)
rescue StandardError => e
  # Handle the error
end
```

##### Feedback and Contributions

Feedback and contributions are welcome. Please report any issues or suggestions through the [GitHub issue tracker](https://github.com/rulebricks/ruby-sdk/issues).

##### License

The Rulebricks Ruby SDK is released under the MIT License. See the LICENSE file for more details.
